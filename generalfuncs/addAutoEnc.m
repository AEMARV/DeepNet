function [ net,currentBlockNum,block ] = addAutoEnc( net,decode,encode,block,lr,currentBlockNum,decrec,encrec )
% Outputs 2^(dec+1-enc)/d^enc blocks. Input should be 2 blocks. 
resBlock = false;
for i = 1 : decode
    if resBlock
        newBlock = block/2;
    else
        newBlock = block;
    end
net.layers{end+1} = struct('type', 'conv', ... 
                           'weights', {{eyeconv(decrec,decrec,block,newBlock*currentBlockNum, 'single'), zeros(1, newBlock*currentBlockNum, 'single')}}, ... 
                           'learningRate', lr, ... 
                           'stride', 1, ... 
                           'blocks', currentBlockNum, ...
                           'pad', floor(decrec/2)) ; 
net.layers{end+1} = struct('type', 'birelu','block',newBlock,'scatter',true) ;
currentBlockNum = currentBlockNum*2;
block = newBlock;
end

if isinf(encode) || encode > floor(log2(currentBlockNum))
    encode = floor(log2(currentBlockNum));
end
for i = 1 :1: encode
    if resBlock
    NewBlock = block *2;
    else
        NewBlock = block;
    end
net.layers{end+1} = struct('type', 'conv', ... 
                           'weights', {{eyeconv(1,1,2*block,NewBlock*currentBlockNum/2, 'single'), zeros(1,NewBlock*currentBlockNum/2, 'single')}}, ... 
                           'learningRate', lr, ... 
                           'stride', 1, ... 
                           'blocks', currentBlockNum/2, ...
                           'pad', floor(encrec/2)) ; 
     block = NewBlock;
net.layers{end+1} = struct('type', 'relu') ;
currentBlockNum = currentBlockNum/2;
if currentBlockNum<1
    error('shit')
end
end
end
% net.layers{end+1} = struct('type', 'conv', ... 
%                            'weights', {{0.01*randn(1,1,k*block,k*2*block, 'single'), zeros(1, k*2*block, 'single')}}, ... 
%                            'learningRate', lr, ... 
%                            'stride', 1, ... 
%                            'pad', 0) ; 
% net.layers{end+1} = struct('type', 'birelu') ;
% net.layers{end+1} = struct('type', 'conv', ... 
%                            'weights', {{0.01*randn(1,1,k*block,k*4*block, 'single'), zeros(1, k*4*block, 'single')}}, ... 
%                            'learningRate', lr, ... 
%                            'stride', 1, ... 
%                            'pad', 0) ; 
% net.layers{end+1} = struct('type', 'birelu') ;
% net.layers{end+1} = struct('type', 'conv', ... 
%                            'weights', {{0.01*randn(1,1,k*block,k*8*block, 'single'), zeros(1, k*8*block, 'single')}}, ... 
%                            'learningRate', lr, ... 
%                            'stride', 1, ... 
%                            'pad', 0) ; 
% net.layers{end+1} = struct('type', 'birelu') ;
% %encode
% net.layers{end+1} = struct('type', 'conv', ... 
%                            'weights', {{0.01*randn(1,1,k*4*block,k*4*block, 'single'), zeros(1, k*4*block, 'single')}}, ... 
%                            'learningRate', lr, ... 
%                            'stride', 1, ... 
%                            'pad', 0) ; 
% net.layers{end+1} = struct('type', 'birelu') ;
% net.layers{end+1} = struct('type', 'conv', ... 
%                            'weights', {{0.01*randn(1,1,k*4*block,k*2*block, 'single'), zeros(1, k*2*block, 'single')}}, ... 
%                            'learningRate', lr, ... 
%                            'stride', 1, ... 
%                            'pad', 0) ; 
% net.layers{end+1} = struct('type', 'birelu') ;
% net.layers{end+1} = struct('type', 'conv', ... 
%                            'weights', {{0.01*randn(1,1,k*4*block,k*1*block, 'single'), zeros(1, k*1*block, 'single')}}, ... 
%                            'learningRate', lr, ... 
%                            'stride', 1, ... 
%                            'pad', 0) ; 
% net.layers{end+1} = struct('type', 'birelu') ;
